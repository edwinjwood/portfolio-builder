[{"filePath":"c:\\VS Projects\\Portfolio Builder\\portfolio-builder\\backend\\scripts\\apply_migrations.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"c:\\VS Projects\\Portfolio Builder\\portfolio-builder\\backend\\scripts\\check_subscription.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"c:\\VS Projects\\Portfolio Builder\\portfolio-builder\\backend\\scripts\\ensure_payments_pk.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"c:\\VS Projects\\Portfolio Builder\\portfolio-builder\\backend\\scripts\\inspect_payments_constraints.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"c:\\VS Projects\\Portfolio Builder\\portfolio-builder\\backend\\scripts\\new_migration.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"c:\\VS Projects\\Portfolio Builder\\portfolio-builder\\backend\\scripts\\reconcile_invoices.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"c:\\VS Projects\\Portfolio Builder\\portfolio-builder\\backend\\scripts\\run_migration.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"c:\\VS Projects\\Portfolio Builder\\portfolio-builder\\backend\\scripts\\run_migration_file.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"c:\\VS Projects\\Portfolio Builder\\portfolio-builder\\backend\\scripts\\sync_price_map.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"c:\\VS Projects\\Portfolio Builder\\portfolio-builder\\backend\\server\\index.js","messages":[{"ruleId":"no-unused-vars","severity":2,"message":"'fs' is assigned a value but never used.","line":10,"column":7,"nodeType":"Identifier","messageId":"unusedVar","endLine":10,"endColumn":9}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// ...existing code...\r\n// ...existing code...\r\n// ...existing code...\r\n\r\nconst express = require('express');\r\nconst cors = require('cors');\r\nconst logoUpload = require('./logoUpload');\r\nconst jwt = require('jsonwebtoken');\r\nconst bcrypt = require('bcryptjs');\r\nconst fs = require('fs');\r\nconst crypto = require('crypto');\r\nconst { Pool } = require('pg');\r\nconst nodemailer = require('nodemailer');\r\nconst rateLimit = require('express-rate-limit');\r\nconst path = require('path');\r\nconst dotenv = require('dotenv');\r\n// Load the canonical backend .env located at backend/.env (one source of truth)\r\nconst backendEnv = path.resolve(__dirname, '..', '.env');\r\ndotenv.config({ path: backendEnv });\r\n\r\nconst app = express();\r\napp.use(cors());\r\n// Parse JSON bodies but keep a copy of the raw buffer for webhook verification\r\napp.use(express.json({\r\n  verify: (req, res, buf) => {\r\n    // Save raw body buffer for routes that need the exact signed payload (Stripe webhooks)\r\n    req.rawBody = buf;\r\n  }\r\n}));\r\napp.use('/api', logoUpload);\r\n\r\nconst JWT_SECRET = process.env.JWT_SECRET || 'your_jwt_secret';\r\nconst pool = new Pool({ connectionString: process.env.DATABASE_URL });\r\n\r\n// Configure mailer (optional). Provide SMTP_HOST, SMTP_PORT, SMTP_USER, SMTP_PASS in backend/.env\r\nlet mailer = null;\r\nif (process.env.SMTP_HOST && process.env.SMTP_USER) {\r\n  mailer = nodemailer.createTransport({\r\n    host: process.env.SMTP_HOST,\r\n    port: parseInt(process.env.SMTP_PORT || '587', 10),\r\n    secure: process.env.SMTP_SECURE === 'true',\r\n    auth: {\r\n      user: process.env.SMTP_USER,\r\n      pass: process.env.SMTP_PASS,\r\n    },\r\n  });\r\n} else {\r\n  console.warn('SMTP not configured. Password reset emails will be logged to console.');\r\n}\r\n\r\n// Stripe setup (requires STRIPE_SECRET_KEY in env)\r\nlet stripe;\r\ntry {\r\n  const Stripe = require('stripe');\r\n  stripe = Stripe(process.env.STRIPE_SECRET_KEY || '');\r\n} catch (err) {\r\n  console.warn('Stripe package not available or not configured. Payments will be disabled.');\r\n  stripe = null;\r\n}\r\n\r\n// Helper: compute a canonical id for related Stripe objects so different events map to the same payment row\r\n// Extract Stripe ids from an event object and compute a canonical id\r\nconst extractStripeIds = (obj) => {\r\n  if (!obj) return { canonicalId: null, paymentIntentId: null, chargeId: null, invoiceId: null };\r\n  // If this is a Stripe event wrapper, unwrap to the actual object\r\n  if (obj.data && obj.data.object) obj = obj.data.object;\r\n  let paymentIntentId = null;\r\n  let chargeId = null;\r\n  let invoiceId = null;\r\n\r\n  // top-level shapes\r\n  if (typeof obj.id === 'string') {\r\n    const id = obj.id;\r\n    if (id.startsWith('pi_')) paymentIntentId = id;\r\n    if (id.startsWith('ch_')) chargeId = id;\r\n    if (id.startsWith('in_')) invoiceId = id;\r\n  }\r\n\r\n  // common fields\r\n  if (!paymentIntentId && obj.payment_intent) {\r\n    if (typeof obj.payment_intent === 'string') paymentIntentId = obj.payment_intent;\r\n    else if (obj.payment_intent && obj.payment_intent.id) paymentIntentId = obj.payment_intent.id;\r\n  }\r\n  if (!chargeId && obj.charge) chargeId = obj.charge;\r\n  if (!invoiceId && obj.invoice) invoiceId = obj.invoice;\r\n\r\n  // nested charges array\r\n  try {\r\n    if (!chargeId && obj.charges && obj.charges.data && obj.charges.data[0]) {\r\n      const c = obj.charges.data[0];\r\n      if (c && c.id) chargeId = c.id;\r\n      if (c && c.payment_intent) paymentIntentId = paymentIntentId || c.payment_intent;\r\n      if (c && c.invoice) invoiceId = invoiceId || c.invoice;\r\n    }\r\n  } catch (e) {\r\n    // ignore\r\n  }\r\n\r\n  // invoice objects sometimes embed a charge in different fields\r\n  if (!chargeId && obj.charge) chargeId = obj.charge;\r\n\r\n  // Determine canonical: prefer payment_intent -> charge -> invoice -> fallback to top-level id\r\n  const canonicalId = paymentIntentId || chargeId || invoiceId || (obj && obj.id ? obj.id : null);\r\n  return { canonicalId, paymentIntentId, chargeId, invoiceId };\r\n};\r\n\r\n// Helper: upsert a payment record using a canonical id to avoid duplicates\r\nconst upsertPayment = async ({ canonicalId, stripeId, stripePaymentIntentId = null, stripeChargeId = null, stripeInvoiceId = null, userId = null, amount = 0, currency = 'usd', status = null, paymentMethod = null, receiptEmail = null, description = null, metadata = null, raw = null }) => {\r\n  if (!canonicalId) canonicalId = stripeId || null;\r\n  if (!canonicalId) return;\r\n  // Debug: log intent to upsert so production logs surface inputs when something fails\r\n  if (process.env.DEBUG_STRIPE_EVENTS === 'true') {\r\n    try { console.log('upsertPayment params:', { canonicalId, stripeId, stripePaymentIntentId, stripeChargeId, stripeInvoiceId, userId, amount, currency, status }); } catch(e) { /* ignore logging errors */ }\r\n  }\r\n\r\n  const client = await pool.connect();\r\n  try {\r\n    await client.query('BEGIN');\r\n    // Insert or update the canonical row\r\n    await client.query(`\r\n      INSERT INTO payments (stripe_id, stripe_canonical_id, stripe_payment_intent_id, stripe_charge_id, stripe_invoice_id, user_id, amount, currency, status, payment_method, receipt_email, description, metadata, raw_event, created_at, updated_at)\r\n      VALUES ($1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14, now(), now())\r\n      ON CONFLICT (stripe_canonical_id) DO UPDATE SET\r\n        stripe_id = COALESCE(payments.stripe_id, EXCLUDED.stripe_id),\r\n        stripe_payment_intent_id = COALESCE(payments.stripe_payment_intent_id, EXCLUDED.stripe_payment_intent_id),\r\n        stripe_charge_id = COALESCE(payments.stripe_charge_id, EXCLUDED.stripe_charge_id),\r\n        stripe_invoice_id = COALESCE(payments.stripe_invoice_id, EXCLUDED.stripe_invoice_id),\r\n        user_id = COALESCE(EXCLUDED.user_id, payments.user_id),\r\n        amount = EXCLUDED.amount,\r\n        currency = EXCLUDED.currency,\r\n        status = EXCLUDED.status,\r\n        payment_method = COALESCE(EXCLUDED.payment_method, payments.payment_method),\r\n        receipt_email = COALESCE(EXCLUDED.receipt_email, payments.receipt_email),\r\n        description = COALESCE(EXCLUDED.description, payments.description),\r\n        metadata = COALESCE(EXCLUDED.metadata, payments.metadata),\r\n        raw_event = EXCLUDED.raw_event,\r\n        updated_at = now()\r\n    `, [stripeId, canonicalId, stripePaymentIntentId, stripeChargeId, stripeInvoiceId, userId, amount, currency, status, paymentMethod, receiptEmail, description, metadata, raw]);\r\n\r\n    // Consolidate any rows that reference the same PI/charge/invoice to this canonical id\r\n    await client.query(`\r\n      UPDATE payments\r\n      SET stripe_canonical_id = $1,\r\n          stripe_payment_intent_id = COALESCE(stripe_payment_intent_id, $2),\r\n          stripe_charge_id = COALESCE(stripe_charge_id, $3),\r\n          stripe_invoice_id = COALESCE(stripe_invoice_id, $4),\r\n          updated_at = now()\r\n      WHERE (stripe_payment_intent_id = $2 OR stripe_charge_id = $3 OR stripe_invoice_id = $4)\r\n        AND COALESCE(stripe_canonical_id, '') <> COALESCE($1, '')\r\n    `, [canonicalId, stripePaymentIntentId, stripeChargeId, stripeInvoiceId]);\r\n\r\n    await client.query('COMMIT');\r\n    if (process.env.DEBUG_STRIPE_EVENTS === 'true') {\r\n      try { console.log('upsertPayment succeeded for canonicalId:', canonicalId); console.log('Merged duplicate payment rows into canonicalId:', canonicalId); } catch(e){}\r\n    }\r\n  } catch (err) {\r\n    try { await client.query('ROLLBACK'); } catch (rbErr) { /* ignore rollback errors */ }\r\n    console.error('Failed to upsert/merge payment by canonical id:', canonicalId, 'error:', err && (err.stack || err.message || err));\r\n  } finally {\r\n    client.release();\r\n  }\r\n};\r\n\r\n\r\n// Get all users route\r\napp.get('/api/users', async (req, res) => {\r\n  try {\r\n    const result = await pool.query('SELECT * FROM users');\r\n    // Map users to include first_name and last_name\r\n    res.json(result.rows.map(u => ({\r\n      id: u.id,\r\n      email: u.email,\r\n      username: u.username,\r\n      role: u.role,\r\n      first_name: u.first_name,\r\n      last_name: u.last_name\r\n    })));\r\n  } catch (err) {\r\n    res.status(500).json({ error: 'Server error.' });\r\n  }\r\n});\r\n\r\n// Create user (signup)\r\napp.post('/api/users', async (req, res) => {\r\n  const { name, email, password, plan } = req.body;\r\n  if (!email || !password) return res.status(400).json({ error: 'Email and password required.' });\r\n  try {\r\n    // Check existing\r\n    const exists = await pool.query('SELECT id FROM users WHERE email = $1', [email]);\r\n    if (exists.rows[0]) return res.status(409).json({ error: 'Email already registered.' });\r\n\r\n    const names = (name || '').split(' ');\r\n    const first_name = names.shift() || null;\r\n    const last_name = names.join(' ') || null;\r\n    // Derive a username: prefer provided name parts, fallback to email local-part\r\n    let username = (first_name && last_name) ? `${first_name}.${last_name}` : null;\r\n    if (!username) {\r\n      username = (email || '').split('@')[0];\r\n    }\r\n    // Sanitize username: allow letters, numbers, dot, underscore, hyphen; lowercase; trim to 30 chars\r\n    username = username.toString().toLowerCase().replace(/[^a-z0-9._-]/g, '').slice(0, 30) || null;\r\n\r\n    // Hash password before storing\r\n    const hashed = await bcrypt.hash(password, 10);\r\n    const result = await pool.query(`\r\n      INSERT INTO users (username, email, password, first_name, last_name, role)\r\n      VALUES ($1,$2,$3,$4,$5,'user')\r\n      RETURNING id, email, username, role, first_name, last_name\r\n    `, [username, email, hashed, first_name, last_name]);\r\n\r\n    const user = result.rows[0];\r\n    // Ensure every user has an initial subscription row. Default to 'individual' when not specified.\r\n    try {\r\n      const key = plan ? plan.toString().toLowerCase() : 'individual';\r\n      let priceId = null;\r\n      try {\r\n        const pm = await pool.query('SELECT price_id FROM plan_price_map WHERE plan_key = $1 AND active = true', [key]);\r\n        if (pm.rows[0]) priceId = pm.rows[0].price_id;\r\n      } catch (e) {\r\n        // ignore\r\n      }\r\n      await pool.query(`\r\n        INSERT INTO subscriptions (user_id, plan_key, price_id, status, created_at, updated_at)\r\n        VALUES ($1,$2,$3,$4, now(), now())\r\n      `, [user.id, key, priceId, 'pending']);\r\n    } catch (subErr) {\r\n      console.warn('Failed to create subscription row at signup:', subErr.message);\r\n    }\r\n    // Optionally create a Stripe Checkout session for the selected plan so the user can complete payment\r\n    let checkout = null;\r\n    try {\r\n      const key = plan ? plan.toString().toLowerCase() : null;\r\n      if (stripe && key) {\r\n        // try to resolve a priceId: prefer plan_price_map value we inserted/read above\r\n        let priceId = null;\r\n        try {\r\n          const pm = await pool.query('SELECT price_id FROM plan_price_map WHERE plan_key = $1 AND active = true', [key]);\r\n          if (pm.rows[0]) priceId = pm.rows[0].price_id;\r\n        } catch (e) {\r\n          // ignore\r\n        }\r\n\r\n        if (priceId) {\r\n          // determine mode (subscription vs payment) by inspecting the price object\r\n          let mode = 'payment';\r\n          try {\r\n            const priceObj = await stripe.prices.retrieve(priceId, { expand: ['product'] });\r\n            if (priceObj && priceObj.recurring) mode = 'subscription';\r\n          } catch (e) {\r\n            // if retrieving price fails, default to payment\r\n          }\r\n\r\n          try {\r\n            const successBase = process.env.CHECKOUT_BASE_URL || process.env.FRONTEND_URL || 'http://localhost:5173';\r\n            // If the frontend is using a HashRouter, Stripe must redirect to a URL containing the hash\r\n            const hashPrefix = process.env.FRONTEND_USE_HASH === 'false' ? '' : '/#';\r\n            const session = await stripe.checkout.sessions.create({\r\n              mode,\r\n              payment_method_types: ['card'],\r\n              line_items: [{ price: priceId, quantity: 1 }],\r\n              success_url: `${successBase}${hashPrefix}/checkout-success?session_id={CHECKOUT_SESSION_ID}`,\r\n              cancel_url: `${successBase}${hashPrefix}/checkout-cancel`,\r\n              customer_email: user.email,\r\n              metadata: { userId: String(user.id), plan: key },\r\n            });\r\n            checkout = { url: session.url, id: session.id, mode };\r\n            console.log('Created Checkout session at signup:', session.id, session.url);\r\n          } catch (e) {\r\n            console.warn('Failed to create checkout session at signup:', e.message || e);\r\n          }\r\n        }\r\n      }\r\n    } catch (err) {\r\n      console.warn('Error while attempting to create checkout session at signup:', err.message || err);\r\n    }\r\n\r\n    // Sign JWT\r\n    const token = jwt.sign({ id: user.id, email: user.email, role: user.role }, JWT_SECRET, { expiresIn: '1h' });\r\n    const resp = { token, user: { id: user.id, email: user.email, username: user.username, role: user.role, first_name: user.first_name, last_name: user.last_name } };\r\n    if (checkout) resp.checkout = checkout;\r\n    res.json(resp);\r\n  } catch (err) {\r\n    console.error('Error creating user:', err);\r\n    res.status(500).json({ error: 'Failed to create user.' });\r\n  }\r\n});\r\n\r\n// Apply rate limiter middleware specifically to password reset requests\r\nconst resetIpLimiter = rateLimit({\r\n  windowMs: 15 * 60 * 1000, // 15 minutes\r\n  max: 6, // limit each IP to 6 requests per windowMs\r\n  standardHeaders: true,\r\n  legacyHeaders: false,\r\n});\r\n\r\n// Password reset request with IP limiter and per-account throttle\r\napp.post('/api/password-reset/request', resetIpLimiter, async (req, res) => {\r\n  const { email } = req.body;\r\n  if (!email) return res.status(400).json({ error: 'Email required.' });\r\n  try {\r\n  // captcha verification is progressive and will be applied later if thresholds are met\r\n    // Look up user once\r\n    const r = await pool.query('SELECT id, email, first_name FROM users WHERE email = $1', [email]);\r\n    if (!r.rows[0]) return res.status(200).json({ success: true }); // don't reveal existence\r\n    const user = r.rows[0];\r\n\r\n    // Per-account throttle: count recent tokens created for this user in last hour\r\n    const countRow = await pool.query(\"SELECT count(*) FROM password_resets WHERE user_id = $1 AND created_at > now() - interval '1 hour'\", [user.id]);\r\n    const count = parseInt(countRow.rows[0].count || '0', 10);\r\n    if (count >= 3) {\r\n      // Too many requests for this account recently\r\n      return res.status(429).json({ error: 'Too many password reset requests for this account. Try again later.' });\r\n    }\r\n\r\n    // Progressive CAPTCHA: require captcha only after a small number of recent requests (e.g., >=2)\r\n    const captchaSecret = process.env.CAPTCHA_SECRET;\r\n    const captchaProvider = (process.env.CAPTCHA_PROVIDER || 'recaptcha').toLowerCase();\r\n    if (captchaSecret && count >= 2) {\r\n      const token = req.body.captchaToken;\r\n      if (!token) return res.status(400).json({ error: 'Captcha token required.' });\r\n      let verified = false;\r\n      try {\r\n        let resp;\r\n        if (captchaProvider === 'hcaptcha') {\r\n          resp = await fetch('https://hcaptcha.com/siteverify', {\r\n            method: 'POST',\r\n            headers: { 'Content-Type': 'application/x-www-form-urlencoded' },\r\n            body: `secret=${encodeURIComponent(captchaSecret)}&response=${encodeURIComponent(token)}`,\r\n          });\r\n        } else {\r\n          resp = await fetch('https://www.google.com/recaptcha/api/siteverify', {\r\n            method: 'POST',\r\n            headers: { 'Content-Type': 'application/x-www-form-urlencoded' },\r\n            body: `secret=${encodeURIComponent(captchaSecret)}&response=${encodeURIComponent(token)}`,\r\n          });\r\n        }\r\n        const j = await resp.json().catch(() => null);\r\n        if (!resp.ok) {\r\n          console.warn('Captcha provider returned non-OK status', resp.status, j || '(no json)');\r\n          return res.status(401).json({ error: 'Captcha provider rejected the verification request.', details: j });\r\n        }\r\n        verified = !!(j && j.success);\r\n        if (!verified) {\r\n          console.warn('Captcha verification failed', j);\r\n          return res.status(401).json({ error: 'Captcha verification failed.', details: j });\r\n        }\r\n      } catch (e) {\r\n        console.warn('Captcha verification error:', e.message || e);\r\n        return res.status(400).json({ error: 'Captcha verification failed (exception).' });\r\n      }\r\n      if (!verified) return res.status(400).json({ error: 'Captcha verification failed.' });\r\n    }\r\n\r\n  const token = crypto.randomBytes(24).toString('hex');\r\n  const tokenHash = crypto.createHash('sha256').update(token).digest('hex');\r\n  const expiresAt = new Date(Date.now() + 1000 * 60 * 60); // 1 hour\r\n  // Store only the token hash in DB for security\r\n  await pool.query('INSERT INTO password_resets (user_id, token, expires_at) VALUES ($1,$2,$3)', [user.id, tokenHash, expiresAt]);\r\n\r\n  const resetUrl = `${process.env.FRONTEND_URL || process.env.CHECKOUT_BASE_URL || 'http://localhost:5173'}/reset-password?token=${token}`;\r\n    const subject = 'Password reset request';\r\n    const text = `Hi ${user.first_name || ''},\\n\\nWe received a request to reset your password. Click the link below to reset it (expires in 1 hour):\\n\\n${resetUrl}\\n\\nIf you didn't request this, you can ignore this message.`;\r\n\r\n    if (mailer) {\r\n      await mailer.sendMail({ from: process.env.SMTP_FROM || 'no-reply@example.com', to: user.email, subject, text });\r\n      return res.json({ success: true });\r\n    }\r\n\r\n  // If no SMTP configured, log the token for local debugging but do not return it to the client.\r\n  console.log('Password reset token (no SMTP):', token, 'for user', user.email);\r\n    return res.json({ success: true });\r\n  } catch (err) {\r\n    console.error('Password reset request failed:', err);\r\n    res.status(500).json({ error: 'Failed to create reset token.' });\r\n  }\r\n});\r\n\r\n// Confirm password reset: verifies token and sets new password\r\napp.post('/api/password-reset/confirm', async (req, res) => {\r\n  const { token, password } = req.body;\r\n  if (!token || !password) return res.status(400).json({ error: 'Token and new password required.' });\r\n  try {\r\n  // Hash incoming token to compare with stored hash\r\n  const tokenHash = crypto.createHash('sha256').update(token).digest('hex');\r\n  const r = await pool.query('SELECT id, user_id, expires_at FROM password_resets WHERE token = $1', [tokenHash]);\r\n    const row = r.rows[0];\r\n    if (!row) return res.status(400).json({ error: 'Invalid or expired token.' });\r\n    if (new Date(row.expires_at) < new Date()) return res.status(400).json({ error: 'Token expired.' });\r\n\r\n    const hashed = await bcrypt.hash(password, 10);\r\n    await pool.query('UPDATE users SET password = $1 WHERE id = $2', [hashed, row.user_id]);\r\n    // delete token\r\n    await pool.query('DELETE FROM password_resets WHERE id = $1', [row.id]);\r\n    return res.json({ success: true });\r\n  } catch (err) {\r\n    console.error('Password reset confirm failed:', err);\r\n    res.status(500).json({ error: 'Failed to reset password.' });\r\n  }\r\n});\r\n\r\n// Login route\r\napp.post('/api/login', async (req, res) => {\r\n  const { email, password } = req.body;\r\n  if (!email || !password) {\r\n    return res.status(400).json({ error: 'Email and password required.' });\r\n  }\r\n  try {\r\n    const result = await pool.query('SELECT * FROM users WHERE email = $1', [email]);\r\n    const user = result.rows[0];\r\n    if (!user) {\r\n      return res.status(401).json({ error: 'Invalid credentials.' });\r\n    }\r\n    // Compare hashed password\r\n    const match = await bcrypt.compare(password, user.password);\r\n    if (!match) {\r\n      return res.status(401).json({ error: 'Invalid credentials.' });\r\n    }\r\n    // Create JWT\r\n    const token = jwt.sign({ id: user.id, email: user.email, role: user.role }, JWT_SECRET, { expiresIn: '1h' });\r\n    res.json({\r\n      token,\r\n      user: {\r\n        id: user.id,\r\n        email: user.email,\r\n        username: user.username,\r\n        role: user.role,\r\n        first_name: user.first_name,\r\n        last_name: user.last_name\r\n      }\r\n    });\r\n  } catch (err) {\r\n    res.status(500).json({ error: 'Server error.' });\r\n  }\r\n});\r\n\r\n// Validate JWT route\r\napp.post('/api/validate', async (req, res) => {\r\n  const authHeader = req.headers['authorization'];\r\n  const token = authHeader && authHeader.split(' ')[1];\r\n  if (!token) {\r\n    return res.status(401).json({ error: 'No token provided.' });\r\n  }\r\n  try {\r\n    const decoded = jwt.verify(token, JWT_SECRET);\r\n    const result = await pool.query('SELECT * FROM users WHERE id = $1', [decoded.id]);\r\n    const user = result.rows[0];\r\n    if (!user) {\r\n      return res.status(404).json({ error: 'User not found.' });\r\n    }\r\n    res.json({\r\n      user: {\r\n        id: user.id,\r\n        email: user.email,\r\n        username: user.username,\r\n        role: user.role,\r\n        first_name: user.first_name,\r\n        last_name: user.last_name\r\n      }\r\n    });\r\n  } catch (err) {\r\n    res.status(401).json({ error: 'Invalid or expired token.' });\r\n  }\r\n});\r\n\r\n// Get portfolios for current user\r\napp.get('/api/portfolios', async (req, res) => {\r\n  const authHeader = req.headers['authorization'];\r\n  const token = authHeader && authHeader.split(' ')[1];\r\n  if (!token) {\r\n    return res.status(401).json({ error: 'No token provided.' });\r\n  }\r\n  let userId;\r\n  try {\r\n    const decoded = jwt.verify(token, JWT_SECRET);\r\n    userId = decoded.id;\r\n  } catch (err) {\r\n    return res.status(401).json({ error: 'Invalid or expired token.' });\r\n  }\r\n  try {\r\n    const result = await pool.query('SELECT * FROM portfolios WHERE user_id = $1', [userId]);\r\n    res.json(result.rows);\r\n  } catch (err) {\r\n    res.status(500).json({ error: 'Server error.' });\r\n  }\r\n});\r\n\r\n// Get a single portfolio by ID for the current user\r\napp.get('/api/portfolios/:id', async (req, res) => {\r\n  const authHeader = req.headers['authorization'];\r\n  const token = authHeader && authHeader.split(' ')[1];\r\n  if (!token) {\r\n    return res.status(401).json({ error: 'No token provided.' });\r\n  }\r\n  let userId;\r\n  try {\r\n    const decoded = jwt.verify(token, JWT_SECRET);\r\n    userId = decoded.id;\r\n  } catch (err) {\r\n    return res.status(401).json({ error: 'Invalid or expired token.' });\r\n  }\r\n  const portfolioId = req.params.id;\r\n  try {\r\n    const result = await pool.query(\r\n      'SELECT * FROM portfolios WHERE id = $1 AND user_id = $2',\r\n      [portfolioId, userId]\r\n    );\r\n    if (result.rows.length === 0) {\r\n      return res.status(404).json({ error: 'Portfolio not found.' });\r\n    }\r\n    res.json(result.rows[0]);\r\n  } catch (err) {\r\n    res.status(500).json({ error: 'Server error.' });\r\n  }\r\n});\r\n\r\n// Create portfolio route\r\napp.post('/api/portfolios', async (req, res) => {\r\n  const authHeader = req.headers['authorization'];\r\n  const token = authHeader && authHeader.split(' ')[1];\r\n  if (!token) {\r\n    return res.status(401).json({ error: 'No token provided.' });\r\n  }\r\n  let userId;\r\n  try {\r\n    const decoded = jwt.verify(token, JWT_SECRET);\r\n    userId = decoded.id;\r\n  } catch (err) {\r\n    return res.status(401).json({ error: 'Invalid or expired token.' });\r\n  }\r\n  const { name } = req.body;\r\n  if (!name) {\r\n    return res.status(400).json({ error: 'Portfolio name required.' });\r\n  }\r\n  try {\r\n    const result = await pool.query(\r\n      'INSERT INTO portfolios (user_id, name) VALUES ($1, $2) RETURNING *',\r\n      [userId, name]\r\n    );\r\n    res.status(201).json(result.rows[0]);\r\n  } catch (err) {\r\n    res.status(500).json({ error: 'Server error.' });\r\n  }\r\n});\r\n\r\n// Delete portfolio route\r\napp.delete('/api/portfolios/:id', async (req, res) => {\r\n  const authHeader = req.headers['authorization'];\r\n  const token = authHeader && authHeader.split(' ')[1];\r\n  if (!token) {\r\n    return res.status(401).json({ error: 'No token provided.' });\r\n  }\r\n  let userId;\r\n  try {\r\n    const decoded = jwt.verify(token, JWT_SECRET);\r\n    userId = decoded.id;\r\n  } catch (err) {\r\n    return res.status(401).json({ error: 'Invalid or expired token.' });\r\n  }\r\n  const portfolioId = req.params.id;\r\n  try {\r\n    // Only delete if the portfolio belongs to the user\r\n    const result = await pool.query(\r\n      'DELETE FROM portfolios WHERE id = $1 AND user_id = $2 RETURNING *',\r\n      [portfolioId, userId]\r\n    );\r\n    if (result.rows.length === 0) {\r\n      return res.status(404).json({ error: 'Portfolio not found or not owned by user.' });\r\n    }\r\n    res.json({ success: true });\r\n  } catch (err) {\r\n    res.status(500).json({ error: 'Server error.' });\r\n  }\r\n});\r\n\r\n// Get all templates with their components\r\napp.get('/api/templates', async (req, res) => {\r\n  try {\r\n    const templates = await pool.query('SELECT * FROM templates ORDER BY id');\r\n    const templateIds = templates.rows.map(t => t.id);\r\n    let components = [];\r\n    if (templateIds.length > 0) {\r\n      const compResult = await pool.query(\r\n        'SELECT * FROM template_components WHERE template_id = ANY($1::int[]) ORDER BY position',\r\n        [templateIds]\r\n      );\r\n      components = compResult.rows;\r\n    }\r\n    // Group components by template_id\r\n    const componentsByTemplate = {};\r\n    components.forEach(c => {\r\n      if (!componentsByTemplate[c.template_id]) componentsByTemplate[c.template_id] = [];\r\n      componentsByTemplate[c.template_id].push(c);\r\n    });\r\n    // Attach components to templates\r\n    const result = templates.rows.map(t => ({\r\n      ...t,\r\n      components: componentsByTemplate[t.id] || []\r\n    }));\r\n    res.json(result);\r\n  } catch (err) {\r\n    res.status(500).json({ error: 'Failed to fetch templates' });\r\n  }\r\n});\r\n\r\n// Return active Stripe prices with expanded product info\r\napp.get('/api/stripe/prices', async (req, res) => {\r\n  if (!stripe) return res.status(503).json({ error: 'Payments not configured.' });\r\n  try {\r\n    const prices = await stripe.prices.list({ limit: 100, active: true, expand: ['data.product'] });\r\n    const mapped = prices.data.map(p => ({\r\n      id: p.id,\r\n      unit_amount: p.unit_amount,\r\n      currency: p.currency,\r\n      recurring: p.recurring || null,\r\n      nickname: p.nickname || null,\r\n      product: p.product ? {\r\n        id: p.product.id,\r\n        name: p.product.name,\r\n        description: p.product.description,\r\n      } : null\r\n    }));\r\n\r\n    // Allow fallback price IDs set in backend/.env for development or when prices\r\n    // are managed outside Stripe listing. Configure these in backend/.env as:\r\n    // PRICE_ID_INDIVIDUAL=price_...\r\n    // PRICE_ID_TEAM=price_...\r\n    // PRICE_ID_ENTERPRISE=price_...\r\n    const fallbackEnvPrices = [];\r\n    if (process.env.PRICE_ID_INDIVIDUAL) {\r\n      fallbackEnvPrices.push({ id: process.env.PRICE_ID_INDIVIDUAL, unit_amount: null, currency: 'usd', recurring: null, nickname: null, product: { id: null, name: 'Individual' } });\r\n    }\r\n    if (process.env.PRICE_ID_TEAM) {\r\n      fallbackEnvPrices.push({ id: process.env.PRICE_ID_TEAM, unit_amount: null, currency: 'usd', recurring: null, nickname: null, product: { id: null, name: 'Team' } });\r\n    }\r\n    if (process.env.PRICE_ID_ENTERPRISE) {\r\n      fallbackEnvPrices.push({ id: process.env.PRICE_ID_ENTERPRISE, unit_amount: null, currency: 'usd', recurring: null, nickname: null, product: { id: null, name: 'Enterprise' } });\r\n    }\r\n\r\n    // Merge and dedupe\r\n    const merged = mapped.slice();\r\n    for (const fp of fallbackEnvPrices) {\r\n      if (!merged.find(m => m.id === fp.id)) merged.push(fp);\r\n    }\r\n\r\n    res.json(merged);\r\n  } catch (err) {\r\n    console.error('Failed to fetch Stripe prices', err);\r\n    res.status(500).json({ error: 'Failed to fetch prices' });\r\n  }\r\n});\r\n\r\n// Return a mapped set of price IDs for known plans (individual, team, enterprise)\r\napp.get('/api/stripe/price-map', async (req, res) => {\r\n  if (!stripe) return res.status(503).json({ error: 'Payments not configured.' });\r\n  try {\r\n    // First, attempt to read canonical mappings from DB table `plan_price_map`\r\n    // Expected rows: plan_key (text) PRIMARY KEY, price_id (text), active boolean\r\n    const dbMap = {};\r\n    try {\r\n      const r = await pool.query('SELECT plan_key, price_id FROM plan_price_map WHERE active = true');\r\n      r.rows.forEach(row => {\r\n        if (row.plan_key && row.price_id) dbMap[row.plan_key.toLowerCase()] = row.price_id;\r\n      });\r\n    } catch (dbErr) {\r\n      // If table doesn't exist or query fails, continue to Stripe lookup\r\n      console.warn('plan_price_map read failed or not present:', dbErr.message);\r\n    }\r\n\r\n    // If DB contains all required keys, return it immediately\r\n    const requiredKeys = ['individual', 'team', 'enterprise'];\r\n    const hasAll = requiredKeys.every(k => !!dbMap[k]);\r\n    if (hasAll) return res.json(dbMap);\r\n\r\n    // Otherwise, fetch Stripe prices and try to derive missing keys\r\n    const prices = await stripe.prices.list({ limit: 200, active: true, expand: ['data.product'] });\r\n    const data = prices.data || [];\r\n\r\n    const normalize = (s) => (s || '').toString().toLowerCase().trim();\r\n    const candidates = { individual: [], team: [], enterprise: [] };\r\n\r\n    data.forEach((p) => {\r\n      const prod = p.product || {};\r\n      const prodName = prod.name ? normalize(prod.name) : '';\r\n      const nick = p.nickname ? normalize(p.nickname) : '';\r\n      const planTag = prod.metadata && prod.metadata.plan ? normalize(prod.metadata.plan) : null;\r\n      const id = p.id;\r\n      const recurring = p.recurring || null;\r\n\r\n      const tests = [];\r\n      if (planTag) tests.push(planTag);\r\n      if (prodName) tests.push(prodName);\r\n      if (nick) tests.push(nick);\r\n\r\n      ['individual', 'team', 'enterprise'].forEach((key) => {\r\n        if (tests.some(t => t.includes(key))) candidates[key].push({ id, recurring, raw: p });\r\n      });\r\n    });\r\n\r\n    const choose = (list) => {\r\n      if (!list || list.length === 0) return null;\r\n      const monthly = list.find(l => l.recurring && l.recurring.interval === 'month');\r\n      if (monthly) return monthly.id;\r\n      const anyRec = list.find(l => l.recurring);\r\n      if (anyRec) return anyRec.id;\r\n      return list[0].id;\r\n    };\r\n\r\n    const stripeMap = {\r\n      individual: choose(candidates.individual) || null,\r\n      team: choose(candidates.team) || null,\r\n      enterprise: choose(candidates.enterprise) || null,\r\n    };\r\n\r\n    // Build final map: prefer DB values, then Stripe-derived, then env fallback\r\n    const finalMap = {};\r\n    for (const key of requiredKeys) {\r\n      finalMap[key] = dbMap[key] || stripeMap[key] || process.env[`PRICE_ID_${key.toUpperCase()}`] || null;\r\n    }\r\n\r\n    // Upsert any discovered Stripe-derived mappings into DB for caching\r\n    try {\r\n      for (const key of requiredKeys) {\r\n        const priceId = finalMap[key];\r\n        if (!priceId) continue;\r\n        // If DB already had it, skip\r\n        if (dbMap[key] && dbMap[key] === priceId) continue;\r\n        await pool.query(`\r\n          INSERT INTO plan_price_map (plan_key, price_id, active, updated_at)\r\n          VALUES ($1,$2,true,now())\r\n          ON CONFLICT (plan_key) DO UPDATE SET price_id = EXCLUDED.price_id, active = EXCLUDED.active, updated_at = now()\r\n        `, [key, priceId]);\r\n      }\r\n    } catch (upErr) {\r\n      console.warn('Failed to upsert plan_price_map entries:', upErr.message);\r\n    }\r\n\r\n    res.json(finalMap);\r\n  } catch (err) {\r\n    console.error('Failed to build price map', err);\r\n    res.status(500).json({ error: 'Failed to build price map' });\r\n  }\r\n});\r\n\r\n// Create PaymentIntent for authenticated users\r\napp.post('/api/payments/create-payment-intent', async (req, res) => {\r\n  if (!stripe) return res.status(503).json({ error: 'Payments not configured.' });\r\n  const authHeader = req.headers['authorization'];\r\n  const token = authHeader && authHeader.split(' ')[1];\r\n  if (!token) return res.status(401).json({ error: 'No token provided.' });\r\n  let userId;\r\n  try {\r\n    const decoded = jwt.verify(token, JWT_SECRET);\r\n    userId = decoded.id;\r\n  } catch (err) {\r\n    return res.status(401).json({ error: 'Invalid or expired token.' });\r\n  }\r\n  const { amount, currency = 'usd' } = req.body;\r\n  if (!amount || typeof amount !== 'number') {\r\n    return res.status(400).json({ error: 'Amount (in cents) required as a number.' });\r\n  }\r\n  try {\r\n    const paymentIntent = await stripe.paymentIntents.create({\r\n      amount,\r\n      currency,\r\n      metadata: { userId: String(userId) }\r\n    });\r\n    res.json({ clientSecret: paymentIntent.client_secret, id: paymentIntent.id });\r\n  } catch (err) {\r\n    console.error('Error creating PaymentIntent:', err);\r\n    res.status(500).json({ error: 'Payment creation failed.' });\r\n  }\r\n});\r\n\r\n// Admin: grouped payments view (non-destructive). Shows logical payment groups by\r\n// stripe_canonical_id / payment_intent / charge / invoice and a heuristic fallback.\r\n// In production this endpoint requires an admin JWT; in non-production it's open for convenience.\r\napp.get('/admin/payments/grouped', async (req, res) => {\r\n  try {\r\n    // Simple admin guard: require role=admin in production\r\n    if (process.env.NODE_ENV === 'production') {\r\n      const auth = req.headers['authorization'];\r\n      const token = auth && auth.split(' ')[1];\r\n      if (!token) return res.status(401).json({ error: 'Unauthorized' });\r\n      try {\r\n        const decoded = jwt.verify(token, JWT_SECRET);\r\n        if (!decoded || decoded.role !== 'admin') return res.status(403).json({ error: 'Forbidden' });\r\n      } catch (e) {\r\n        return res.status(401).json({ error: 'Invalid token' });\r\n      }\r\n    }\r\n\r\n    const q = await pool.query(`SELECT id, stripe_id, stripe_canonical_id, stripe_payment_intent_id, stripe_charge_id, stripe_invoice_id, amount, status, metadata, raw_event, created_at, updated_at, user_id FROM payments ORDER BY updated_at DESC`);\r\n    const rows = q.rows || [];\r\n\r\n    // Initial grouping by explicit ids or heuristic\r\n    const groups = new Map();\r\n    const addToGroup = (key, reason, row) => {\r\n      if (!groups.has(key)) groups.set(key, { key, reasons: new Set([reason]), payments: [], ids: new Set() });\r\n      const g = groups.get(key);\r\n      g.reasons.add(reason);\r\n      g.payments.push(row);\r\n      ['stripe_canonical_id','stripe_payment_intent_id','stripe_charge_id','stripe_invoice_id','stripe_id'].forEach(f => { if (row[f]) g.ids.add(row[f]); });\r\n    };\r\n\r\n    for (const r of rows) {\r\n      if (r.stripe_canonical_id) {\r\n        addToGroup(`canonical:${r.stripe_canonical_id}`, 'canonical', r);\r\n        continue;\r\n      }\r\n      if (r.stripe_payment_intent_id) {\r\n        addToGroup(`pi:${r.stripe_payment_intent_id}`, 'payment_intent', r);\r\n        continue;\r\n      }\r\n      if (r.stripe_charge_id) {\r\n        addToGroup(`ch:${r.stripe_charge_id}`, 'charge', r);\r\n        continue;\r\n      }\r\n      if (r.stripe_invoice_id) {\r\n        addToGroup(`in:${r.stripe_invoice_id}`, 'invoice', r);\r\n        continue;\r\n      }\r\n      // heuristic: customer + amount + 5-min bucket\r\n      let customer = null;\r\n      try { customer = (r.raw_event && r.raw_event.customer) || (r.metadata && (r.metadata.userId || r.metadata.customer)) || null; } catch(e) { customer = null; }\r\n      const ts = r.created_at ? Math.floor(new Date(r.created_at).getTime() / 1000 / 300) : 'no_ts';\r\n      const hkey = `heur:${customer||'anon'}:${r.amount || 0}:${ts}`;\r\n      addToGroup(hkey, 'heuristic', r);\r\n    }\r\n\r\n    // Merge groups that share any stripe ids (connected components)\r\n    const groupKeys = Array.from(groups.keys());\r\n    const adj = new Map();\r\n    // build adjacency\r\n    for (let i=0;i<groupKeys.length;i++) {\r\n      const a = groupKeys[i];\r\n      const aids = groups.get(a).ids;\r\n      for (let j=i+1;j<groupKeys.length;j++) {\r\n        const b = groupKeys[j];\r\n        const bids = groups.get(b).ids;\r\n        // check intersection\r\n        let intersect = false;\r\n        for (const id of aids) { if (bids.has(id)) { intersect = true; break; } }\r\n        if (intersect) {\r\n          if (!adj.has(a)) adj.set(a, new Set());\r\n          if (!adj.has(b)) adj.set(b, new Set());\r\n          adj.get(a).add(b); adj.get(b).add(a);\r\n        }\r\n      }\r\n    }\r\n\r\n    // find connected components\r\n    const visited = new Set();\r\n    const merged = [];\r\n    for (const start of groupKeys) {\r\n      if (visited.has(start)) continue;\r\n      const stack = [start];\r\n      const comp = new Set();\r\n      while (stack.length) {\r\n        const k = stack.pop();\r\n        if (visited.has(k)) continue;\r\n        visited.add(k); comp.add(k);\r\n        const neighbors = adj.get(k);\r\n        if (neighbors) for (const n of neighbors) if (!visited.has(n)) stack.push(n);\r\n      }\r\n      // merge component groups\r\n      const mergedGroup = { keys: Array.from(comp), reasons: new Set(), payments: [], ids: new Set() };\r\n      for (const k of comp) {\r\n        const g = groups.get(k);\r\n        if (!g) continue;\r\n        g.reasons.forEach(r => mergedGroup.reasons.add(r));\r\n        for (const p of g.payments) mergedGroup.payments.push(p);\r\n        for (const id of g.ids) mergedGroup.ids.add(id);\r\n      }\r\n      // aggregate\r\n      const total_amount = mergedGroup.payments.reduce((s,p)=>s + (p.amount||0), 0);\r\n      const count = mergedGroup.payments.length;\r\n      const users = Array.from(new Set(mergedGroup.payments.map(p=>p.user_id).filter(Boolean)));\r\n      const statuses = Array.from(new Set(mergedGroup.payments.map(p=>p.status).filter(Boolean)));\r\n      merged.push({ keys: mergedGroup.keys, reasons: Array.from(mergedGroup.reasons), count, total_amount, users, statuses, payments: mergedGroup.payments });\r\n    }\r\n\r\n    res.json({ groups: merged, total_payments: rows.length });\r\n  } catch (err) {\r\n    console.error('Failed to build grouped payments:', err);\r\n    res.status(500).json({ error: 'Failed to build grouped payments' });\r\n  }\r\n});\r\n\r\n// Admin debug: DB status and lightweight inspection\r\napp.get('/admin/debug/db-status', async (req, res) => {\r\n  try {\r\n    // In production require admin JWT\r\n    if (process.env.NODE_ENV === 'production') {\r\n      const auth = req.headers['authorization'];\r\n      const token = auth && auth.split(' ')[1];\r\n      if (!token) return res.status(401).json({ error: 'Unauthorized' });\r\n      try {\r\n        const decoded = jwt.verify(token, JWT_SECRET);\r\n        if (!decoded || decoded.role !== 'admin') return res.status(403).json({ error: 'Forbidden' });\r\n      } catch (e) {\r\n        return res.status(401).json({ error: 'Invalid token' });\r\n      }\r\n    }\r\n\r\n    const paymentsCountR = await pool.query('SELECT count(*) FROM payments');\r\n    const subsCountR = await pool.query(\"SELECT count(*) FROM subscriptions WHERE status = 'pending'\");\r\n    const recentPayments = await pool.query('SELECT id, stripe_id, stripe_canonical_id, amount, status, created_at FROM payments ORDER BY created_at DESC LIMIT 10');\r\n    const recentSubs = await pool.query('SELECT id, user_id, plan_key, status, stripe_subscription_id, updated_at FROM subscriptions ORDER BY updated_at DESC LIMIT 10');\r\n\r\n    res.json({ payments_total: paymentsCountR.rows[0].count, subscriptions_pending: subsCountR.rows[0].count, recentPayments: recentPayments.rows, recentSubscriptions: recentSubs.rows });\r\n  } catch (err) {\r\n    console.error('admin debug db-status failed:', err && (err.stack || err.message || err));\r\n    res.status(500).json({ error: 'Failed to inspect DB' });\r\n  }\r\n});\r\n\r\n// Admin debug: run migrations remotely when explicitly allowed via env var\r\napp.post('/admin/debug/run-migrations', async (req, res) => {\r\n  // safety: only allow when ALLOW_REMOTE_MIGRATIONS === 'true'\r\n  if (process.env.ALLOW_REMOTE_MIGRATIONS !== 'true') {\r\n    return res.status(403).json({ error: 'Remote migrations not enabled' });\r\n  }\r\n  // admin guard in production\r\n  if (process.env.NODE_ENV === 'production') {\r\n    const auth = req.headers['authorization'];\r\n    const token = auth && auth.split(' ')[1];\r\n    if (!token) return res.status(401).json({ error: 'Unauthorized' });\r\n    try {\r\n      const decoded = jwt.verify(token, JWT_SECRET);\r\n      if (!decoded || decoded.role !== 'admin') return res.status(403).json({ error: 'Forbidden' });\r\n    } catch (e) {\r\n      return res.status(401).json({ error: 'Invalid token' });\r\n    }\r\n  }\r\n\r\n  try {\r\n    const { exec } = require('child_process');\r\n    const cwd = path.resolve(__dirname, '..');\r\n    exec('node ./scripts/apply_migrations.js', { cwd, maxBuffer: 1024 * 1024 }, (err, stdout, stderr) => {\r\n      if (err) {\r\n        console.error('Remote migrations failed:', err && (err.stack || err.message || err));\r\n        return res.status(500).json({ error: 'Migration runner failed', details: stderr || err.message });\r\n      }\r\n      res.json({ success: true, out: stdout });\r\n    });\r\n  } catch (e) {\r\n    console.error('Failed to start migration process:', e && (e.stack || e.message || e));\r\n    res.status(500).json({ error: 'Failed to start migrations' });\r\n  }\r\n});\r\n\r\n// Create a Stripe Checkout Session for price-based purchases/subscriptions\r\napp.post('/api/checkout/create-session', async (req, res) => {\r\n  if (!stripe) return res.status(503).json({ error: 'Payments not configured.' });\r\n  const { priceId, mode = 'payment', successUrl, cancelUrl } = req.body;\r\n  if (!priceId) return res.status(400).json({ error: 'priceId is required.' });\r\n\r\n  // Try to identify user from JWT if present\r\n  const authHeader = req.headers['authorization'];\r\n  const token = authHeader && authHeader.split(' ')[1];\r\n  let userId = null;\r\n  let customerEmail = null;\r\n  if (token) {\r\n    try {\r\n      const decoded = jwt.verify(token, JWT_SECRET);\r\n      userId = decoded.id;\r\n      const u = await pool.query('SELECT email FROM users WHERE id = $1', [userId]);\r\n      if (u.rows[0]) customerEmail = u.rows[0].email;\r\n    } catch (err) {\r\n      // ignore token errors; session can be created without user\r\n      userId = null;\r\n    }\r\n  }\r\n\r\n  try {\r\n    // Determine base URL for frontend callbacks. Prefer explicit CHECKOUT_BASE_URL, then FRONTEND_URL,\r\n    // fallback to localhost for local development.\r\n    const successBase = process.env.CHECKOUT_BASE_URL || process.env.FRONTEND_URL || 'http://localhost:5173';\r\n    const hashPrefix = process.env.FRONTEND_USE_HASH === 'false' ? '' : '/#';\r\n    const defaultSuccess = `${successBase}${hashPrefix}/checkout?session_id={CHECKOUT_SESSION_ID}`;\r\n    const defaultCancel = `${successBase}${hashPrefix}/checkout`;\r\n\r\n    // Try to resolve a canonical plan_key for this priceId so webhooks can update subscriptions\r\n    let planKey = null;\r\n    try {\r\n      const pmRes = await pool.query('SELECT plan_key FROM plan_price_map WHERE price_id = $1 AND active = true', [priceId]);\r\n      if (pmRes.rows[0]) planKey = pmRes.rows[0].plan_key;\r\n    } catch (e) {\r\n      // ignore lookup errors\r\n    }\r\n\r\n    const session = await stripe.checkout.sessions.create({\r\n      mode: mode, // 'payment' or 'subscription'\r\n      payment_method_types: ['card'],\r\n      line_items: [{ price: priceId, quantity: 1 }],\r\n      // Force a stable locale to avoid dynamic locale module resolution on Stripe's side\r\n      locale: 'en',\r\n      success_url: successUrl || process.env.CHECKOUT_SUCCESS_URL || defaultSuccess,\r\n      cancel_url: cancelUrl || process.env.CHECKOUT_CANCEL_URL || defaultCancel,\r\n      customer_email: customerEmail || undefined,\r\n  metadata: { userId: userId ? String(userId) : null, priceId, plan: planKey },\r\n    });\r\n\r\n    res.json({ url: session.url, id: session.id });\r\n  } catch (err) {\r\n    console.error('Error creating Checkout session:', err);\r\n    res.status(500).json({ error: 'Failed to create checkout session.' });\r\n  }\r\n});\r\n\r\n// Fetch a checkout session and return session metadata + user token if available\r\napp.get('/api/checkout/session', async (req, res) => {\r\n  const sessionId = req.query.session_id;\r\n  if (!sessionId) return res.status(400).json({ error: 'session_id required' });\r\n  if (!stripe) return res.status(503).json({ error: 'Payments not configured' });\r\n  try {\r\n    const session = await stripe.checkout.sessions.retrieve(sessionId, { expand: ['subscription', 'payment_intent'] });\r\n    const metadata = session.metadata || {};\r\n    let user = null;\r\n    let token = null;\r\n    if (metadata.userId) {\r\n      try {\r\n        const r = await pool.query('SELECT id, email, username, role, first_name, last_name FROM users WHERE id = $1', [metadata.userId]);\r\n        user = r.rows[0] || null;\r\n        if (user) {\r\n          token = jwt.sign({ id: user.id, email: user.email, role: user.role }, JWT_SECRET, { expiresIn: '1h' });\r\n        }\r\n      } catch (e) {\r\n        console.warn('Failed to load user for checkout session:', e.message || e);\r\n      }\r\n    }\r\n    res.json({ session, user, token });\r\n  } catch (err) {\r\n    console.error('Error fetching checkout session:', err.message || err);\r\n    res.status(500).json({ error: 'Failed to fetch session' });\r\n  }\r\n});\r\n\r\n// Stripe webhook endpoint - uses raw body for signature verification\r\napp.post('/webhooks/stripe', async (req, res) => {\r\n  if (!stripe) return res.status(503).send('Payments not configured.');\r\n  const sig = req.headers['stripe-signature'];\r\n  let event;\r\n  try {\r\n    const payload = req.rawBody || (req.body && JSON.stringify(req.body));\r\n    if (!payload) {\r\n      console.error('No raw payload available for webhook signature verification.');\r\n      return res.status(400).send('No payload for webhook verification.');\r\n    }\r\n    // Construct event using raw payload (Buffer or string)\r\n    event = stripe.webhooks.constructEvent(payload, sig, process.env.STRIPE_WEBHOOK_SECRET);\r\n  } catch (err) {\r\n    console.error('Webhook signature verification failed.', err.message);\r\n    return res.status(400).send(`Webhook Error: ${err.message}`);\r\n  }\r\n\r\n  // Helper: compute a canonical id for related Stripe objects so different events map to the same payment row\r\n  // Extract Stripe ids from an event object and compute a canonical id\r\n  const extractStripeIds = (obj) => {\r\n    if (!obj) return { canonicalId: null, paymentIntentId: null, chargeId: null, invoiceId: null };\r\n    let paymentIntentId = null;\r\n    let chargeId = null;\r\n    let invoiceId = null;\r\n\r\n    // top-level shapes\r\n    if (typeof obj.id === 'string') {\r\n      const id = obj.id;\r\n      if (id.startsWith('pi_')) paymentIntentId = id;\r\n      if (id.startsWith('ch_')) chargeId = id;\r\n      if (id.startsWith('in_')) invoiceId = id;\r\n    }\r\n\r\n    // common fields\r\n    if (!paymentIntentId && obj.payment_intent) {\r\n      if (typeof obj.payment_intent === 'string') paymentIntentId = obj.payment_intent;\r\n      else if (obj.payment_intent && obj.payment_intent.id) paymentIntentId = obj.payment_intent.id;\r\n    }\r\n    if (!chargeId && obj.charge) chargeId = obj.charge;\r\n    if (!invoiceId && obj.invoice) invoiceId = obj.invoice;\r\n\r\n    // nested charges array\r\n    try {\r\n      if (!chargeId && obj.charges && obj.charges.data && obj.charges.data[0]) {\r\n        const c = obj.charges.data[0];\r\n        if (c && c.id) chargeId = c.id;\r\n        if (c && c.payment_intent) paymentIntentId = paymentIntentId || c.payment_intent;\r\n        if (c && c.invoice) invoiceId = invoiceId || c.invoice;\r\n      }\r\n    } catch (e) {\r\n      // ignore\r\n    }\r\n\r\n    // invoice objects sometimes embed a charge in different fields\r\n    if (!chargeId && obj.charge) chargeId = obj.charge;\r\n\r\n  // Determine canonical: prefer payment_intent -> charge -> invoice -> fallback to top-level id\r\n  const canonicalId = paymentIntentId || chargeId || invoiceId || (obj && obj.id ? obj.id : null);\r\n    return { canonicalId, paymentIntentId, chargeId, invoiceId };\r\n  };\r\n\r\n  // Helper: upsert a payment record using a canonical id to avoid duplicates\r\n  const upsertPayment = async ({ canonicalId, stripeId, stripePaymentIntentId = null, stripeChargeId = null, stripeInvoiceId = null, userId = null, amount = 0, currency = 'usd', status = null, paymentMethod = null, receiptEmail = null, description = null, metadata = null, raw = null }) => {\r\n    if (!canonicalId) canonicalId = stripeId || null;\r\n    if (!canonicalId) return;\r\n    // Debug: log intent to upsert so production logs surface inputs when something fails\r\n    if (process.env.DEBUG_STRIPE_EVENTS === 'true') {\r\n      try { console.log('upsertPayment params:', { canonicalId, stripeId, stripePaymentIntentId, stripeChargeId, stripeInvoiceId, userId, amount, currency, status }); } catch(e) { /* ignore logging errors */ }\r\n    }\r\n\r\n    const client = await pool.connect();\r\n    try {\r\n      await client.query('BEGIN');\r\n      // Insert or update the canonical row\r\n      await client.query(`\r\n        INSERT INTO payments (stripe_id, stripe_canonical_id, stripe_payment_intent_id, stripe_charge_id, stripe_invoice_id, user_id, amount, currency, status, payment_method, receipt_email, description, metadata, raw_event, created_at, updated_at)\r\n        VALUES ($1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14, now(), now())\r\n        ON CONFLICT (stripe_canonical_id) DO UPDATE SET\r\n          stripe_id = COALESCE(payments.stripe_id, EXCLUDED.stripe_id),\r\n          stripe_payment_intent_id = COALESCE(payments.stripe_payment_intent_id, EXCLUDED.stripe_payment_intent_id),\r\n          stripe_charge_id = COALESCE(payments.stripe_charge_id, EXCLUDED.stripe_charge_id),\r\n          stripe_invoice_id = COALESCE(payments.stripe_invoice_id, EXCLUDED.stripe_invoice_id),\r\n          user_id = COALESCE(EXCLUDED.user_id, payments.user_id),\r\n          amount = EXCLUDED.amount,\r\n          currency = EXCLUDED.currency,\r\n          status = EXCLUDED.status,\r\n          payment_method = COALESCE(EXCLUDED.payment_method, payments.payment_method),\r\n          receipt_email = COALESCE(EXCLUDED.receipt_email, payments.receipt_email),\r\n          description = COALESCE(EXCLUDED.description, payments.description),\r\n          metadata = COALESCE(EXCLUDED.metadata, payments.metadata),\r\n          raw_event = EXCLUDED.raw_event,\r\n          updated_at = now()\r\n      `, [stripeId, canonicalId, stripePaymentIntentId, stripeChargeId, stripeInvoiceId, userId, amount, currency, status, paymentMethod, receiptEmail, description, metadata, raw]);\r\n\r\n      // Consolidate any rows that reference the same PI/charge/invoice to this canonical id\r\n      await client.query(`\r\n        UPDATE payments\r\n        SET stripe_canonical_id = $1,\r\n            stripe_payment_intent_id = COALESCE(stripe_payment_intent_id, $2),\r\n            stripe_charge_id = COALESCE(stripe_charge_id, $3),\r\n            stripe_invoice_id = COALESCE(stripe_invoice_id, $4),\r\n            updated_at = now()\r\n        WHERE (stripe_payment_intent_id = $2 OR stripe_charge_id = $3 OR stripe_invoice_id = $4)\r\n          AND COALESCE(stripe_canonical_id, '') <> COALESCE($1, '')\r\n      `, [canonicalId, stripePaymentIntentId, stripeChargeId, stripeInvoiceId]);\r\n\r\n      await client.query('COMMIT');\r\n      if (process.env.DEBUG_STRIPE_EVENTS === 'true') {\r\n        try { console.log('upsertPayment succeeded for canonicalId:', canonicalId); console.log('Merged duplicate payment rows into canonicalId:', canonicalId); } catch(e){}\r\n      }\r\n    } catch (err) {\r\n      try { await client.query('ROLLBACK'); } catch (rbErr) { /* ignore rollback errors */ }\r\n      console.error('Failed to upsert/merge payment by canonical id:', canonicalId, 'error:', err && (err.stack || err.message || err));\r\n    } finally {\r\n      client.release();\r\n    }\r\n  };\r\n\r\n  // Handle the event types you care about\r\n  try {\r\n    // Surface every event so we can debug missing upserts in production\r\n    try {\r\n      if (event && event.type) {\r\n        console.log('Stripe webhook received:', event.type, event.id || '(no id)');\r\n      }\r\n    } catch (e) { /* ignore logging errors */ }\r\n    switch (event.type) {\r\n      case 'payment_intent.succeeded': {\r\n        const pi = event.data.object;\r\n        console.log('PaymentIntent succeeded:', pi.id, 'amount:', pi.amount);\r\n        const raw = JSON.stringify(pi);\r\n        const metadata = pi.metadata || null;\r\n        const paymentMethod = pi.payment_method || (pi.charges && pi.charges.data && pi.charges.data[0] && (pi.charges.data[0].payment_method || (pi.charges.data[0].payment_method_details && pi.charges.data[0].payment_method_details.type))) || null;\r\n        const receiptEmail = pi.receipt_email || (pi.charges && pi.charges.data && pi.charges.data[0] && pi.charges.data[0].receipt_email) || null;\r\n        const description = pi.description || null;\r\n  const ids = extractStripeIds(pi);\r\n  const canonicalId = ids.canonicalId || pi.id;\r\n  // Try to populate userId from metadata, or fallback to customer or checkout session metadata\r\n  let userIdForPi = pi.metadata?.userId || null;\r\n  if (!userIdForPi) {\r\n    try {\r\n      if (pi.customer) {\r\n        const cust = await stripe.customers.retrieve(pi.customer);\r\n        userIdForPi = cust && cust.metadata && cust.metadata.userId ? cust.metadata.userId : userIdForPi;\r\n      }\r\n      if (!userIdForPi) {\r\n        try {\r\n          const sessions = await stripe.checkout.sessions.list({ limit: 1, payment_intent: pi.id });\r\n          if (sessions && sessions.data && sessions.data[0]) userIdForPi = sessions.data[0].metadata?.userId || userIdForPi;\r\n        } catch (e) { /* ignore session lookup failure */ }\r\n      }\r\n    } catch (e) { /* ignore customer lookup failure */ }\r\n  }\r\n  await upsertPayment({ canonicalId, stripeId: pi.id, stripePaymentIntentId: ids.paymentIntentId, stripeChargeId: ids.chargeId, stripeInvoiceId: ids.invoiceId, userId: userIdForPi, amount: pi.amount, currency: pi.currency, status: pi.status, paymentMethod, receiptEmail, description, metadata, raw });\r\n        break;\r\n      }\r\n      case 'payment_intent.payment_failed': {\r\n        const pi = event.data.object;\r\n        console.log('PaymentIntent failed:', pi.id, pi.last_payment_error && pi.last_payment_error.message);\r\n        const raw = JSON.stringify(pi);\r\n        const metadata = pi.metadata || null;\r\n        const paymentMethod = pi.payment_method || null;\r\n        const receiptEmail = pi.receipt_email || null;\r\n        const description = pi.description || null;\r\n  const ids = extractStripeIds(pi);\r\n  const canonicalId = ids.canonicalId || pi.id;\r\n  await upsertPayment({ canonicalId, stripeId: pi.id, stripePaymentIntentId: ids.paymentIntentId, stripeChargeId: ids.chargeId, stripeInvoiceId: ids.invoiceId, userId: pi.metadata?.userId || null, amount: pi.amount || 0, currency: pi.currency || 'usd', status: pi.status || 'failed', paymentMethod, receiptEmail, description, metadata, raw });\r\n        break;\r\n      }\r\n      case 'checkout.session.completed': {\r\n        const session = event.data.object;\r\n  console.log('Checkout session completed:', session.id);\r\n  try { console.log('  session.metadata:', session.metadata || {}); } catch(e){}\r\n        try {\r\n          const metadata = session.metadata || {};\r\n          const userId = metadata.userId || null;\r\n          const planKey = metadata.plan || null;\r\n          // If we have a user and plan, mark the matching subscription active\r\n          if (userId && planKey) {\r\n            await pool.query(`\r\n              UPDATE subscriptions\r\n              SET status = $1, stripe_subscription_id = $2, updated_at = now()\r\n              WHERE user_id = $3 AND plan_key = $4\r\n            `, ['active', session.subscription || null, userId, planKey]);\r\n          }\r\n          // If the session includes a payment_intent, proactively upsert a payment row\r\n          // using the session metadata so payments will be linked to the user immediately.\r\n          try {\r\n            if (session.payment_intent) {\r\n              let pi = session.payment_intent;\r\n              try {\r\n                if (typeof pi === 'string') {\r\n                  pi = await stripe.paymentIntents.retrieve(pi, { expand: ['charges.data'] });\r\n                }\r\n              } catch (e) {\r\n                // ignore retrieval failures\r\n              }\r\n              const ids = extractStripeIds(pi);\r\n              const canonicalId = ids.canonicalId || (pi && pi.id) || session.payment_intent;\r\n              const chargeId = ids.chargeId || (pi && pi.charges && pi.charges.data && pi.charges.data[0] && pi.charges.data[0].id) || null;\r\n              const amount = (pi && pi.amount) || (pi && pi.charges && pi.charges.data && pi.charges.data[0] && pi.charges.data[0].amount) || 0;\r\n              const currency = (pi && pi.currency) || 'usd';\r\n              const status = (pi && pi.status) || 'succeeded';\r\n              const userForPayment = metadata.userId || (pi && pi.metadata && pi.metadata.userId) || null;\r\n              await upsertPayment({ canonicalId, stripeId: (pi && pi.id) || session.payment_intent, stripePaymentIntentId: ids.paymentIntentId || (pi && pi.id) || null, stripeChargeId: chargeId, stripeInvoiceId: ids.invoiceId || null, userId: userForPayment, amount, currency, status, paymentMethod: (pi && pi.payment_method) || null, receiptEmail: (pi && pi.receipt_email) || null, description: (pi && pi.description) || null, metadata: metadata || (pi && pi.metadata) || null, raw: JSON.stringify(pi || session) });\r\n            }\r\n          } catch (e) {\r\n            console.warn('Failed to upsert payment from checkout.session.completed:', e && (e.stack || e.message || e));\r\n          }\r\n        } catch (e) {\r\n          console.warn('Failed to activate subscription from checkout.session.completed:', e.message);\r\n        }\r\n        break;\r\n      }\r\n      case 'invoice.payment_succeeded': {\r\n        const invoice = event.data.object;\r\n  console.log('Invoice payment succeeded:', invoice.id);\r\n  try { console.log('  invoice.subscription:', invoice.subscription, 'invoice.metadata:', invoice.metadata || {}, 'amount_paid:', invoice.amount_paid); } catch(e){}\r\n        try {\r\n          const metadata = invoice.metadata || {};\r\n          const userId = metadata.userId || null;\r\n          const planKey = metadata.plan || null;\r\n          // If subscription id is present, try to activate subscription rows matching subscription id\r\n          const subId = invoice.subscription || null;\r\n          if (userId && planKey) {\r\n            await pool.query(`\r\n              UPDATE subscriptions\r\n              SET status = $1, updated_at = now(), stripe_subscription_id = COALESCE(stripe_subscription_id, $2)\r\n              WHERE user_id = $3 AND plan_key = $4\r\n            `, ['active', subId, userId, planKey]);\r\n          } else if (subId) {\r\n            await pool.query(`\r\n              UPDATE subscriptions\r\n              SET status = $1, updated_at = now()\r\n              WHERE stripe_subscription_id = $2\r\n            `, ['active', subId]);\r\n          }\r\n        } catch (e) {\r\n          console.warn('Failed to activate subscription from invoice.payment_succeeded:', e.message);\r\n        }\r\n        break;\r\n      }\r\n  case 'invoice.paid': {\r\n        // Some integrations emit invoice.paid; handle same as invoice.payment_succeeded\r\n        const invoice = event.data.object;\r\n  console.log('Invoice paid:', invoice.id);\r\n  try { console.log('  invoice.subscription:', invoice.subscription, 'invoice.metadata:', invoice.metadata || {}, 'amount_paid:', invoice.amount_paid); } catch(e){}\r\n        try {\r\n          const metadata = invoice.metadata || {};\r\n          const userId = metadata.userId || null;\r\n          const planKey = metadata.plan || null;\r\n          const subId = invoice.subscription || null;\r\n          const raw = JSON.stringify(invoice);\r\n          const amount = invoice.amount_paid || invoice.total || 0;\r\n          const currency = invoice.currency || 'usd';\r\n          const ids = extractStripeIds(invoice);\r\n          const canonicalId = ids.canonicalId || invoice.id;\r\n          await upsertPayment({ canonicalId, stripeId: invoice.id, stripePaymentIntentId: ids.paymentIntentId, stripeChargeId: ids.chargeId, stripeInvoiceId: ids.invoiceId, userId, amount, currency, status: invoice.paid ? 'succeeded' : 'pending', description: invoice.description || null, metadata, raw });\r\n\r\n          if (userId && planKey) {\r\n            await pool.query(`\r\n              UPDATE subscriptions\r\n              SET status = $1, updated_at = now(), stripe_subscription_id = COALESCE(stripe_subscription_id, $2)\r\n              WHERE user_id = $3 AND plan_key = $4\r\n            `, ['active', subId, userId, planKey]);\r\n          } else if (subId) {\r\n            await pool.query(`\r\n              UPDATE subscriptions\r\n              SET status = $1, updated_at = now()\r\n              WHERE stripe_subscription_id = $2\r\n            `, ['active', subId]);\r\n          }\r\n        } catch (e) {\r\n          console.warn('Failed to persist invoice.paid:', e.message || e);\r\n        }\r\n        break;\r\n      }\r\n      case 'charge.succeeded': {\r\n        const charge = event.data.object;\r\n        console.log('Charge succeeded:', charge.id, 'amount:', charge.amount);\r\n        try {\r\n          const raw = JSON.stringify(charge);\r\n          const metadata = charge.metadata || null;\r\n          const receiptEmail = charge.receipt_email || null;\r\n          const paymentMethod = charge.payment_method || (charge.payment_method_details && charge.payment_method_details.type) || null;\r\n          const ids = extractStripeIds(charge);\r\n          const canonicalId = ids.canonicalId || charge.id;\r\n          // Attempt to derive userId from charge metadata, related payment_intent, or customer\r\n          let userIdForCharge = charge.metadata?.userId || null;\r\n          if (!userIdForCharge) {\r\n            try {\r\n              if (ids.paymentIntentId || charge.payment_intent) {\r\n                const piId = ids.paymentIntentId || charge.payment_intent;\r\n                const piObj = await stripe.paymentIntents.retrieve(piId);\r\n                userIdForCharge = piObj && piObj.metadata && piObj.metadata.userId ? piObj.metadata.userId : userIdForCharge;\r\n                if (!userIdForCharge && piObj && piObj.customer) {\r\n                  const cust = await stripe.customers.retrieve(piObj.customer);\r\n                  userIdForCharge = cust && cust.metadata && cust.metadata.userId ? cust.metadata.userId : userIdForCharge;\r\n                }\r\n              } else if (charge.customer) {\r\n                const cust = await stripe.customers.retrieve(charge.customer);\r\n                userIdForCharge = cust && cust.metadata && cust.metadata.userId ? cust.metadata.userId : userIdForCharge;\r\n              }\r\n            } catch (e) { /* ignore lookup failures */ }\r\n          }\r\n          await upsertPayment({ canonicalId, stripeId: charge.id, stripePaymentIntentId: ids.paymentIntentId, stripeChargeId: ids.chargeId, stripeInvoiceId: ids.invoiceId, userId: userIdForCharge, amount: charge.amount, currency: charge.currency, status: charge.status || 'succeeded', paymentMethod, receiptEmail, description: charge.description || null, metadata, raw });\r\n        } catch (e) {\r\n          console.warn('Failed to persist charge.succeeded:', e.message || e);\r\n        }\r\n        break;\r\n      }\r\n      case 'charge.refunded': {\r\n        const charge = event.data.object;\r\n        console.log('Charge refunded:', charge.id);\r\n        try {\r\n          const raw = JSON.stringify(charge);\r\n          const metadata = charge.metadata || null;\r\n          const ids = extractStripeIds(charge);\r\n          const canonicalId = ids.canonicalId || charge.id;\r\n          await upsertPayment({ canonicalId, stripeId: charge.id, stripePaymentIntentId: ids.paymentIntentId, stripeChargeId: ids.chargeId, stripeInvoiceId: ids.invoiceId, userId: charge.metadata?.userId || null, amount: charge.amount || 0, currency: charge.currency || 'usd', status: 'refunded', description: charge.description || null, metadata, raw });\r\n        } catch (e) {\r\n          console.warn('Failed to persist charge.refunded:', e.message || e);\r\n        }\r\n        break;\r\n      }\r\n      case 'customer.subscription.created': {\r\n        const sub = event.data.object;\r\n        console.log('Customer subscription created:', sub.id);\r\n        try {\r\n          const metadata = sub.metadata || {};\r\n          const userId = metadata.userId || null;\r\n          const planKey = metadata.plan || null;\r\n          if (userId && planKey) {\r\n            await pool.query(`\r\n              UPDATE subscriptions\r\n              SET status = $1, updated_at = now(), stripe_subscription_id = $2\r\n              WHERE user_id = $3 AND plan_key = $4\r\n            `, ['active', sub.id, userId, planKey]);\r\n          } else {\r\n            // Fallback: mark any subscription with matching stripe id active\r\n            await pool.query(`\r\n              UPDATE subscriptions\r\n              SET status = $1, updated_at = now()\r\n              WHERE stripe_subscription_id = $2\r\n            `, ['active', sub.id]);\r\n          }\r\n        } catch (e) {\r\n          console.warn('Failed to activate subscription from customer.subscription.created:', e.message);\r\n        }\r\n        break;\r\n      }\r\n      default:\r\n        // Quiet by default: only emit unhandled event logs during development\r\n        if (process.env.NODE_ENV !== 'production' || process.env.DEBUG_STRIPE_EVENTS === 'true') {\r\n          console.debug(`Unhandled Stripe event type: ${event.type}`);\r\n        }\r\n    }\r\n  } catch (procErr) {\r\n    console.error('Error processing webhook event:', procErr);\r\n  }\r\n\r\n  res.json({ received: true });\r\n});\r\n\r\n// Export app and pool for testing\r\n// Export app, pool, and helpers for testing\r\nmodule.exports = { app, pool, extractStripeIds, upsertPayment };\r\n\r\n// Only start listening if this file is the main module\r\nif (require.main === module) {\r\n  const PORT = process.env.PORT || 5001;\r\n  app.listen(PORT, () => {\r\n    console.log(`Server running on port ${PORT}`);\r\n  });\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"c:\\VS Projects\\Portfolio Builder\\portfolio-builder\\backend\\server\\logoUpload.js","messages":[{"ruleId":"no-unused-vars","severity":2,"message":"'tenantId' is assigned a value but never used.","line":10,"column":11,"nodeType":"Identifier","messageId":"unusedVar","endLine":10,"endColumn":19}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"const express = require('express');\r\nconst multer = require('multer');\r\nconst path = require('path');\r\nconst fs = require('fs');\r\n\r\nconst router = express.Router();\r\n\r\nconst storage = multer.diskStorage({\r\n  destination: function (req, file, cb) {\r\n    const tenantId = req.body.tenantId;\r\n    const dir = path.join(__dirname, '../assets/tenant-logos');\r\n    if (!fs.existsSync(dir)) {\r\n      fs.mkdirSync(dir, { recursive: true });\r\n    }\r\n    cb(null, dir);\r\n  },\r\n  filename: function (req, file, cb) {\r\n    // Get tenantId from query string\r\n    let tenantId = req.query.tenantId;\r\n    if (!tenantId) tenantId = 'unknown';\r\n    cb(null, `${tenantId}-logo${path.extname(file.originalname)}`);\r\n  }\r\n});\r\n\r\nconst upload = multer({ storage });\r\n\r\nrouter.post('/upload-logo', upload.single('logo'), (req, res) => {\r\n  if (!req.file) {\r\n    return res.status(400).json({ error: 'No file uploaded' });\r\n  }\r\n  const tenantId = req.query.tenantId;\r\n  const logoPath = `/assets/tenant-logos/${tenantId}-logo${path.extname(req.file.originalname)}`;\r\n  res.json({ logoUrl: logoPath });\r\n});\r\n\r\nmodule.exports = router;\r\n","usedDeprecatedRules":[]},{"filePath":"c:\\VS Projects\\Portfolio Builder\\portfolio-builder\\backend\\tools\\backfill_invoice_links.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"c:\\VS Projects\\Portfolio Builder\\portfolio-builder\\backend\\tools\\backfill_subscriptions.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"c:\\VS Projects\\Portfolio Builder\\portfolio-builder\\backend\\tools\\check_payments.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"c:\\VS Projects\\Portfolio Builder\\portfolio-builder\\backend\\tools\\find_unused_decls.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"c:\\VS Projects\\Portfolio Builder\\portfolio-builder\\backend\\tools\\inspect_db.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"c:\\VS Projects\\Portfolio Builder\\portfolio-builder\\backend\\tools\\print_payments.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"c:\\VS Projects\\Portfolio Builder\\portfolio-builder\\backend\\tools\\print_price_map.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"c:\\VS Projects\\Portfolio Builder\\portfolio-builder\\backend\\tools\\run_eslint_unused.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"c:\\VS Projects\\Portfolio Builder\\portfolio-builder\\backend\\tools\\signup_e2e_test.js","messages":[{"ruleId":"no-unused-vars","severity":2,"message":"'fs' is assigned a value but never used.","line":3,"column":7,"nodeType":"Identifier","messageId":"unusedVar","endLine":3,"endColumn":9}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Simple signup e2e test - posts to backend /api/users and prints response\r\nconst fetch = global.fetch || require('node-fetch');\r\nconst fs = require('fs');\r\nconst path = require('path');\r\nconst dotenv = require('dotenv');\r\ndotenv.config({ path: path.resolve(__dirname, '..', '.env') });\r\n(async () => {\r\n  const api = process.env.API_URL || 'http://localhost:5001';\r\n  const email = `test+stripe+${Date.now()}@example.com`;\r\n  const body = { name: 'E2E Test', email, password: 'Password123!', plan: 'individual' };\r\n  try {\r\n    const res = await fetch(`${api}/api/users`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(body) });\r\n    const data = await res.json();\r\n    console.log('status', res.status);\r\n    console.dir(data, { depth: 4 });\r\n  } catch (err) {\r\n    console.error('failed', err);\r\n  }\r\n})();\r\n","usedDeprecatedRules":[]},{"filePath":"c:\\VS Projects\\Portfolio Builder\\portfolio-builder\\backend\\tools\\signup_test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"c:\\VS Projects\\Portfolio Builder\\portfolio-builder\\backend\\tools\\temp_signup_test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]}]